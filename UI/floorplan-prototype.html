<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark" />
    <title>hass-dash – Floorplan Prototype</title>
    <style>
      :root {
        /* Theme tokens aligned with tailwind.config.js (no new colors) */
        --accent: #ffb65c;
        --accent-light: #ffc97d;
        --accent-dark: #e5a352;

        /* Prototype marker color */
        --node-blue: #4da3ff;

        --panel-bg: #090909;
        --panel-bg-warm: #1a1713;
        --panel-surface: #121212;
        --panel-card: #151515;
        --panel-border: #1f1f1f;
        --panel-border-light: #2a2a2a;

        --text-primary: #eae7df;
        --text-secondary: #b9b6af;
        --text-muted: #8a8885;

        --success: #4caf50;
        --warning: #ff9800;
        --danger: #f44336;

        --radius-lg: 28px;
        --radius-md: 18px;
        --radius-sm: 14px;

        --shadow-soft: 0 30px 100px rgba(0, 0, 0, 0.55);
        --shadow-card: 0 16px 50px rgba(0, 0, 0, 0.45);

        --blur-strong: blur(18px);
        --blur-soft: blur(10px);

        /* Floorplan stroke weights (SVG user units; non-scaling due to vector-effect) */
        --wall-stroke-width: 6.33;
        --wall-stroke-width-hover: 6.33;
        --wall-stroke-width-active: 6.33;
        --wall-active-glow-blur: 2em;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          'Apple Color Emoji',
          'Segoe UI Emoji';
        color: var(--text-primary);
        background:
          radial-gradient(1000px 520px at 50% 0%, rgba(255, 182, 92, 0.22), transparent 62%),
          radial-gradient(900px 520px at 12% 12%, rgba(255, 201, 125, 0.1), transparent 58%),
          radial-gradient(900px 520px at 86% 18%, rgba(255, 182, 92, 0.08), transparent 60%),
          linear-gradient(135deg, var(--panel-bg-warm) 0%, #0e0d0b 50%, var(--panel-bg) 100%);
        overflow: hidden;
      }

      a {
        color: inherit;
      }

      .viewport {
        height: 100%;
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .frame {
        width: min(1200px, 100%);
        aspect-ratio: 16 / 9;
        border-radius: var(--radius-lg);
        background: rgba(10, 10, 10, 0.56);
        border: 1px solid rgba(255, 255, 255, 0.07);
        box-shadow: var(--shadow-soft);
        overflow: hidden;
        position: relative;
      }

      .frame::before {
        content: '';
        position: absolute;
        inset: -120px;
        background: radial-gradient(
          700px 360px at 50% 10%,
          rgba(255, 182, 92, 0.22),
          transparent 70%
        );
        filter: blur(32px);
        pointer-events: none;
      }

      .frame::after {
        content: '';
        position: absolute;
        inset: 0;
        background:
          radial-gradient(1200px 680px at 50% 40%, transparent 40%, rgba(0, 0, 0, 0.85) 85%),
          linear-gradient(to bottom, rgba(0, 0, 0, 0.62), rgba(0, 0, 0, 0.28));
        pointer-events: none;
      }

      .app {
        position: relative;
        z-index: 1;
        height: 100%;
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 22px;
        padding: 26px;
        min-height: 0;
      }

      .sidebar {
        padding: 20px 18px;
        border-radius: var(--radius-md);
        background: rgba(9, 9, 9, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.06);
        backdrop-filter: var(--blur-soft);
        box-shadow: var(--shadow-card);
        display: flex;
        flex-direction: column;
        gap: 18px;
        min-height: 0;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 6px 6px 14px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }

      .brand svg {
        width: 34px;
        height: 34px;
        opacity: 0.9;
      }

      .brand .title {
        font-size: 26px;
        letter-spacing: 0.2px;
        color: var(--text-primary);
      }

      .quick-actions {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 14px;
        padding: 2px 6px 0;
      }

      .qa {
        display: grid;
        place-items: center;
        text-decoration: none;
        border-radius: 14px;
        padding: 10px 8px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        background: rgba(18, 18, 18, 0.3);
        backdrop-filter: blur(8px);
        transition:
          transform 140ms ease,
          background-color 140ms ease,
          border-color 140ms ease;
        user-select: none;
      }

      button.qa {
        appearance: none;
        cursor: pointer;
        color: inherit;
        font: inherit;
      }

      .qa:focus-visible {
        outline: 2px solid rgba(255, 201, 125, 0.55);
        outline-offset: 2px;
      }

      .qa:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 201, 125, 0.28);
        background: rgba(18, 18, 18, 0.42);
      }

      .qa .label {
        margin-top: 6px;
        font-size: 13px;
        color: var(--text-secondary);
        letter-spacing: 0.2px;
      }

      .qa svg {
        width: 26px;
        height: 26px;
        opacity: 0.92;
        color: rgba(234, 231, 223, 0.9);
      }

      .agenda {
        padding: 12px 10px 8px;
        flex: 1;
        min-height: 0;
        overflow: auto;
      }

      .status-block {
        margin: 0 6px;
        padding: 10px 10px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        background: rgba(18, 18, 18, 0.22);
        color: rgba(185, 182, 175, 0.92);
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
        word-break: break-word;
        font-variant-numeric: tabular-nums;
      }

      .agenda .item {
        display: grid;
        grid-template-columns: 1fr;
        gap: 2px;
        padding: 10px 8px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        background: rgba(18, 18, 18, 0.2);
        margin-bottom: 10px;
      }

      .agenda .item:last-child {
        margin-bottom: 0;
      }

      .agenda .name {
        color: var(--text-primary);
        font-size: 14px;
        letter-spacing: 0.2px;
      }

      .agenda .time {
        color: var(--text-muted);
        font-size: 12px;
      }

      .stage {
        position: relative;
        border-radius: var(--radius-md);
        background: rgba(9, 9, 9, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.06);
        backdrop-filter: var(--blur-soft);
        box-shadow: var(--shadow-card);
        overflow: hidden;
        min-height: 0;
      }

      .weather {
        pointer-events: auto;
        display: grid;
        grid-template-columns: 44px auto;
        gap: 12px;
        align-items: center;
        padding: 10px 12px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        background: rgba(18, 18, 18, 0.28);
        backdrop-filter: blur(10px);
      }

      .weather .temp {
        font-size: 34px;
        line-height: 1;
        letter-spacing: 0.2px;
      }

      .weather .desc {
        font-size: 13px;
        color: var(--text-secondary);
      }

      .weather .meta {
        margin-top: 2px;
        font-size: 12px;
        color: var(--text-muted);
        letter-spacing: 0.2px;
      }

      .weather svg {
        width: 44px;
        height: 44px;
        opacity: 0.92;
      }

      .floorplan {
        position: absolute;
        inset: 0;
        padding: 22px 22px 26px;
      }

      .floorplan-empty {
        position: absolute;
        inset: 22px;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 20px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(9, 9, 9, 0.62);
        backdrop-filter: blur(10px);
      }

      .floorplan-empty__panel {
        max-width: 720px;
        width: 100%;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(18, 18, 18, 0.3);
        padding: 16px 16px;
      }

      .floorplan-empty__title {
        margin: 0 0 8px;
        font-size: 18px;
        font-weight: 750;
        letter-spacing: 0.2px;
        color: rgba(234, 231, 223, 0.92);
      }

      .floorplan-empty__body {
        margin: 0;
        color: rgba(185, 182, 175, 0.92);
        font-size: 14px;
        line-height: 1.4;
        white-space: pre-wrap;
      }

      .floorplan-empty__actions {
        margin-top: 14px;
        display: flex;
        justify-content: center;
      }

      .floorplan-empty__btn {
        appearance: none;
        height: 44px;
        padding: 0 16px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(18, 18, 18, 0.3);
        color: rgba(234, 231, 223, 0.92);
        font: inherit;
        font-weight: 650;
        letter-spacing: 0.2px;
        cursor: pointer;
        user-select: none;
      }

      .floorplan-empty__btn:hover {
        border-color: rgba(255, 201, 125, 0.28);
        background: rgba(18, 18, 18, 0.42);
      }

      .floorplan-empty__btn:focus-visible {
        outline: 2px solid rgba(255, 201, 125, 0.55);
        outline-offset: 2px;
      }

      .floorplan-empty__btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .floorplan svg {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        cursor: grab;
      }

      .floorplan svg.is-panning {
        cursor: grabbing;
      }

      .map-controls {
        position: absolute;
        right: 18px;
        bottom: 18px;
        z-index: 42;
        width: min(280px, calc(100% - 36px));
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(9, 9, 9, 0.46);
        backdrop-filter: blur(10px);
        padding: 12px 12px 10px;
        box-shadow: 0 14px 46px rgba(0, 0, 0, 0.42);
      }

      .map-controls.is-hidden {
        display: none;
      }

      .map-controls__top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
      }

      .map-controls__camera {
        display: grid;
        gap: 2px;
        min-width: 0;
      }

      .map-controls__camera-line {
        display: flex;
        align-items: baseline;
        gap: 8px;
        white-space: nowrap;
        font-variant-numeric: tabular-nums;
      }

      .map-controls__close {
        appearance: none;
        width: 34px;
        height: 34px;
        padding: 0;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(9, 9, 9, 0.5);
        color: rgba(234, 231, 223, 0.88);
        font-size: 14px;
        line-height: 1;
        cursor: pointer;
        user-select: none;
      }

      .map-controls__close:hover {
        border-color: rgba(255, 201, 125, 0.28);
        background: rgba(18, 18, 18, 0.42);
      }

      .map-controls__close:focus-visible {
        outline: 2px solid rgba(255, 201, 125, 0.55);
        outline-offset: 2px;
      }

      .map-controls-toggle {
        position: absolute;
        right: 18px;
        bottom: 18px;
        z-index: 41;
        width: 44px;
        height: 44px;
        padding: 0;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(18, 18, 18, 0.26);
        backdrop-filter: blur(10px);
        box-shadow: 0 14px 46px rgba(0, 0, 0, 0.42);
        color: rgba(234, 231, 223, 0.92);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      .map-controls-toggle.is-hidden {
        display: none;
      }

      .map-controls-toggle:hover {
        border-color: rgba(255, 201, 125, 0.28);
        background: rgba(18, 18, 18, 0.42);
      }

      .map-controls-toggle:focus-visible {
        outline: 2px solid rgba(255, 201, 125, 0.55);
        outline-offset: 2px;
      }

      .map-controls-toggle svg {
        width: 22px;
        height: 22px;
        opacity: 0.95;
      }

      .map-controls__row {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 10px;
      }

      .map-controls__zoom {
        display: grid;
        gap: 6px;
      }

      .map-controls__zoom-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .map-controls__stack {
        display: grid;
        grid-template-rows: 1fr 1fr;
        gap: 6px;
      }

      .map-controls__label {
        font-size: 12px;
        color: rgba(234, 231, 223, 0.78);
        letter-spacing: 0.2px;
      }

      .map-controls__value {
        font-size: 12px;
        color: rgba(234, 231, 223, 0.72);
        font-variant-numeric: tabular-nums;
      }

      .map-controls__slider {
        width: 100%;
        accent-color: var(--accent);
      }

      .map-controls__btn {
        appearance: none;
        width: 34px;
        height: 34px;
        padding: 0;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(9, 9, 9, 0.5);
        color: rgba(234, 231, 223, 0.88);
        font-size: 14px;
        line-height: 1;
        cursor: pointer;
        user-select: none;
      }

      .map-controls__btn:hover {
        border-color: rgba(255, 201, 125, 0.28);
        background: rgba(18, 18, 18, 0.42);
      }

      .map-controls__btn:focus-visible {
        outline: 2px solid rgba(255, 201, 125, 0.55);
        outline-offset: 2px;
      }

      /* Room interaction (YAML-driven SVG) */
      .room {
        cursor: pointer;
      }

      /*
        Browsers may draw a very heavy default focus outline for focusable SVG elements
        (our rooms are focusable for keyboard support). Disable the UA outline and
        provide a controlled focus-visible style instead.
      */
      .room:focus {
        outline: none;
      }

      .room:focus-visible .room-shape {
        stroke-width: var(--wall-stroke-width-hover);
        filter: url(#roomInnerGlow) drop-shadow(0 0 10px rgba(255, 201, 125, 0.45));
      }

      .room:focus-visible .room-label {
        fill: rgba(255, 201, 125, 0.92);
      }

      .room-shape {
        fill: rgba(18, 18, 18, 0.62);
        stroke: rgb(53, 37, 4);
        stroke-width: var(--wall-stroke-width);
        stroke-linejoin: round;
        stroke-linecap: round;
        vector-effect: non-scaling-stroke;
      }

      .room-label {
        fill: rgba(234, 231, 223, 0.88);
        font-weight: 650;
        letter-spacing: 0.02em;
        user-select: none;
        pointer-events: none;
      }

      .node-dot {
        fill: var(--node-blue);
        stroke: rgba(0, 0, 0, 0.45);
        stroke-width: 0.08;
        vector-effect: non-scaling-stroke;
        pointer-events: none;
      }

      .node-label {
        fill: var(--node-blue);
        font-weight: 600;
        letter-spacing: 0.02em;
        user-select: none;
        pointer-events: none;
      }

      .device-marker {
        pointer-events: none;
      }

      .device-pin {
        filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.55));
      }

      .device-label {
        fill: currentColor;
        font-weight: 650;
        letter-spacing: 0.02em;
        user-select: none;
        pointer-events: none;
      }

      .room:hover:not(.is-active) .room-shape {
        stroke: rgb(53, 37, 4);
        stroke-width: var(--wall-stroke-width-hover);
        fill: rgba(18, 18, 18, 0.52);
        /* filter: url(#roomInnerGlow)
          drop-shadow(0 0 var(--wall-active-glow-blur) rgba(255, 201, 125, 0.55)); */
      }

      .room:hover:not(.is-active) .room-label {
        fill: rgba(255, 201, 125, 0.92);
      }

      .room.is-active .room-shape {
        stroke: rgb(53, 37, 4);
        stroke-width: var(--wall-stroke-width-active);
        fill: rgba(18, 18, 18, 0.95);
        /* filter: url(#roomInnerGlow)
          drop-shadow(0 0 var(--wall-active-glow-blur) rgba(255, 182, 92, 0.95)); */
      }

      .room.is-active .room-label {
        fill: rgba(255, 201, 125, 0.92);
      }

      .tile {
        border-radius: 22px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(18, 18, 18, 0.26);
        padding: 20px 18px;
        min-height: 260px;
        position: relative;
        overflow: hidden;
      }

      .tile::before {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(
          220px 160px at 30% 18%,
          rgba(255, 182, 92, 0.16),
          transparent 72%
        );
        opacity: 0.35;
        pointer-events: none;
      }

      .tile .icon {
        width: 72px;
        height: 72px;
        margin: 2px 0 10px;
        opacity: 0.96;
        filter: drop-shadow(0 18px 28px rgba(0, 0, 0, 0.7));
      }

      .tile .name {
        font-size: 28px;
        margin: 0;
        letter-spacing: 0.2px;
      }

      .tile .status {
        margin-top: 2px;
        font-size: 20px;
        color: rgba(185, 182, 175, 0.9);
      }

      .tile .big {
        position: absolute;
        left: 18px;
        bottom: 18px;
        font-size: 54px;
        font-weight: 800;
        letter-spacing: 0.3px;
        color: rgba(234, 231, 223, 0.92);
      }

      .tile .media {
        display: grid;
        gap: 8px;
        margin-top: 8px;
        align-content: start;
      }

      .tile .media .track {
        font-size: 24px;
        font-weight: 700;
      }

      .tile .media .artist {
        color: rgba(185, 182, 175, 0.9);
      }

      .tile .controls {
        position: absolute;
        left: 18px;
        right: 18px;
        bottom: 18px;
        display: grid;
        gap: 12px;
      }

      .tile .buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .tile .btn {
        height: 44px;
        display: grid;
        place-items: center;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(18, 18, 18, 0.3);
      }

      .tile .btn svg {
        width: 20px;
        height: 20px;
        opacity: 0.9;
      }

      .tile .scrub {
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        overflow: hidden;
      }

      .tile .scrub span {
        display: block;
        width: 44%;
        height: 100%;
        background: rgba(234, 231, 223, 0.7);
      }

      .tile .avatar {
        position: absolute;
        right: 18px;
        bottom: 18px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .tile .avatar .pic {
        width: 56px;
        height: 56px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background:
          radial-gradient(18px 18px at 30% 28%, rgba(255, 255, 255, 0.3), transparent 60%),
          radial-gradient(20px 20px at 70% 40%, rgba(255, 201, 125, 0.24), transparent 60%),
          linear-gradient(145deg, rgba(255, 255, 255, 0.12), rgba(18, 18, 18, 0.12));
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
      }

      .tile .avatar .who {
        font-size: 22px;
        font-weight: 700;
      }

      /* Floating media player (draggable) */
      .media-window {
        position: absolute;
        top: 92px;
        left: 54px;
        width: 360px;
        min-height: 220px;
        z-index: 10;
        background: rgba(18, 18, 18, 0.96);
      }

      .is-hidden {
        display: none !important;
      }

      .media-window__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px 6px;
        margin: -6px -6px 10px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(18, 18, 18, 0.22);
        cursor: grab;
        user-select: none;
      }

      .media-window__header:active {
        cursor: grabbing;
      }

      .media-window__title {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
        color: rgba(185, 182, 175, 0.92);
        letter-spacing: 0.2px;
      }

      .media-window__pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(9, 9, 9, 0.38);
      }

      .media-window__pill svg {
        width: 16px;
        height: 16px;
        opacity: 0.9;
      }

      .media-window__hint {
        font-size: 12px;
        color: rgba(138, 136, 133, 0.95);
      }

      /* Small screens: allow scroll, stack layout */
      @media (max-width: 980px) {
        body {
          overflow: auto;
        }

        .frame {
          aspect-ratio: auto;
          height: auto;
          min-height: 720px;
        }

        .app {
          grid-template-columns: 1fr;
        }

        .sidebar {
          order: 2;
        }

        .stage {
          order: 1;
          min-height: 520px;
        }

        .tile {
          min-height: 220px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .qa {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <a id="top"></a>
    <div class="viewport">
      <div class="frame" role="application" aria-label="Floorplan prototype">
        <div class="app">
          <aside class="sidebar" aria-label="Home controls">
            <div class="brand">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path fill="currentColor" d="M10.5 20v-6h3v6h4.5v-8h2L12 3 1 12h2v8z" />
              </svg>
              <div class="title">Home</div>
            </div>

            <div class="weather" aria-label="Weather summary">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                  fill="currentColor"
                  d="M6 14.5a4.5 4.5 0 0 1 4.43-4.5A5.5 5.5 0 0 1 21 12.5a4.5 4.5 0 0 1-4.5 4.5H7.5A3.5 3.5 0 0 1 6 14.5zm4.5 4.5h2l-1 3h-2l1-3zm4 0h2l-1 3h-2l1-3z"
                />
              </svg>
              <div>
                <div class="temp">4.8°C</div>
                <div class="desc">Breezy and foggy for the hour</div>
                <div class="meta">humidity: 47%</div>
              </div>
            </div>

            <div class="quick-actions" aria-label="Quick actions">
              <a class="qa" href="#top" aria-label="All Off (prototype)">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M13 3h-2v10h2V3zm4.83 2.17-1.42 1.42A7.97 7.97 0 0 1 20 12a8 8 0 1 1-14.41-4.41L4.17 6.17A9.95 9.95 0 0 0 2 12a10 10 0 1 0 18-6a9.95 9.95 0 0 0-2.17-.83z"
                  />
                </svg>
                <div class="label">All Off</div>
              </a>
              <a class="qa" href="#top" aria-label="Bright (prototype)">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12zm0-14V1h0v3zm0 22v-3h0v3zM4.22 5.64 2.1 3.51l1.41-1.41 2.12 2.12L4.22 5.64zM21.9 20.49l-1.41 1.41-2.12-2.12 1.41-1.41 2.12 2.12zM1 12h3v0H1zm22 0h-3v0h3zM4.22 18.36l1.41 1.41-2.12 2.12-1.41-1.41 2.12-2.12zM19.78 5.64 18.36 4.22l2.12-2.12 1.41 1.41-2.12 2.13z"
                  />
                </svg>
                <div class="label">Bright</div>
              </a>
              <a class="qa" href="#top" aria-label="Warm (prototype)">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M12 2a7 7 0 0 0-4 12.74V22h8v-7.26A7 7 0 0 0 12 2zm3 18H9v-4.5h6V20zm0-6.5H9v-0.86A5 5 0 1 1 15 12.64v0.86z"
                  />
                </svg>
                <div class="label">Warm</div>
              </a>
              <a class="qa" href="#top" aria-label="Cabin (prototype)">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M19.36 10.46 12 4.58 4.64 10.46 3.4 8.9 12 2l8.6 6.9-1.24 1.56zM5 11h14v11h-6v-7H11v7H5V11z"
                  />
                </svg>
                <div class="label">Cabin</div>
              </a>
              <button
                class="qa"
                type="button"
                id="media-toggle"
                aria-label="Media"
                aria-controls="media-window"
                aria-expanded="false"
              >
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M18 4v2h2v14H4V6h2V4H2v18h20V4h-4zM8 4v2h2V4H8zm4 0v2h2V4h-2zm4 0v2h2V4h-2z"
                  />
                </svg>
                <div class="label">Media</div>
              </button>
              <a class="qa" href="#top" aria-label="More (prototype)">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path fill="currentColor" d="M7 10l5 5 5-5H7z" />
                </svg>
                <div class="label">More</div>
              </a>
            </div>

            <div class="agenda" aria-label="Agenda">
              <div class="item">
                <div class="name">Weekend In</div>
                <div class="time">Until 7:00 PM</div>
              </div>
              <div class="item">
                <div class="name">Lunch at the park</div>
                <div class="time">11:00 AM – 2:00 PM</div>
              </div>
              <div class="item">
                <div class="name">Install New Home Batteries and Solar</div>
                <div class="time">All Day</div>
              </div>
              <div class="item">
                <div class="name">Take Out Garbage</div>
                <div class="time">All Day</div>
              </div>
              <div class="item">
                <div class="name">Farmers Market</div>
                <div class="time">All Day</div>
              </div>
            </div>

            <pre class="status-block" id="floorplan-status"></pre>
          </aside>

          <main class="stage" aria-label="Floorplan">
            <div class="floorplan" aria-label="Interactive SVG floorplan">
              <div class="floorplan-empty is-hidden" id="floorplan-empty" role="alert" aria-live="polite">
                <div class="floorplan-empty__panel">
                  <h2 class="floorplan-empty__title">Floorplan not loaded</h2>
                  <p class="floorplan-empty__body" id="floorplan-empty-message"></p>
                  <div class="floorplan-empty__actions">
                    <button class="floorplan-empty__btn" id="floorplan-retry" type="button">
                      Try again
                    </button>
                  </div>
                </div>
              </div>

              <svg
                id="floorplan-svg"
                viewBox="0 0 10 10"
                role="img"
                aria-label="Home floorplan (from YAML)"
              >
                <defs>
                  <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="6" result="blur" />
                    <feColorMatrix
                      in="blur"
                      type="matrix"
                      values="1 0 0 0 0.12  0 1 0 0 0.08  0 0 1 0 0  0 0 0 1 0"
                      result="tint"
                    />
                    <feMerge>
                      <feMergeNode in="tint" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>

                  <!-- Inner glow for room polygons (accent color; clipped to the inside of the shape) -->
                  <filter
                    id="roomInnerGlow"
                    x="-5%"
                    y="-5%"
                    width="95%"
                    height="95%"
                    color-interpolation-filters="sRGB"
                  >
                    <feGaussianBlur in="SourceAlpha" stdDeviation="3" result="blur" />
                    <feComposite in="blur" in2="SourceAlpha" operator="in" result="innerBlur" />
                    <feFlood flood-color="#ffb65c" flood-opacity="0.28" result="glowColor" />
                    <feComposite in="glowColor" in2="innerBlur" operator="in" result="glow" />
                    <feMerge>
                      <feMergeNode in="glow" />
                      <feMergeNode in="SourceGraphic" />
                    </feMerge>
                  </filter>

                  <linearGradient id="wall" x1="0" x2="0" y1="0" y2="1">
                    <stop offset="0" stop-color="rgba(255,255,255,0.10)" />
                    <stop offset="1" stop-color="rgba(255,255,255,0.04)" />
                  </linearGradient>

                  <linearGradient id="floorWood" x1="0" x2="1" y1="0" y2="1">
                    <stop offset="0" stop-color="rgba(255, 182, 92, 0.08)" />
                    <stop offset="1" stop-color="rgba(0, 0, 0, 0)" />
                  </linearGradient>

                  <!-- Device/person pin marker (outer color = currentColor) -->
                  <symbol id="devicePin" viewBox="0 0 64 64">
                    <path
                      d="M32 3C20.4 3 11 12.4 11 24c0 15.7 17.5 32.7 20.1 35.2.5.5 1.2.8 1.9.8s1.4-.3 1.9-.8C35.5 56.7 53 39.7 53 24 53 12.4 43.6 3 32 3z"
                      fill="currentColor"
                    />
                    <circle cx="32" cy="24" r="16" fill="var(--text-primary)" fill-opacity="0.96" />
                    <circle cx="32" cy="21" r="6.2" fill="var(--panel-bg)" fill-opacity="0.72" />
                    <path
                      d="M20.5 40.5c2.9-6.4 9-9.8 11.5-9.8s8.6 3.4 11.5 9.8"
                      fill="none"
                      stroke="var(--panel-bg)"
                      stroke-opacity="0.72"
                      stroke-width="7.2"
                      stroke-linecap="round"
                    />
                    <circle
                      cx="32"
                      cy="24"
                      r="16"
                      fill="none"
                      stroke="var(--panel-bg)"
                      stroke-opacity="0.2"
                      stroke-width="1.2"
                    />
                  </symbol>
                </defs>
                <g id="rooms-layer"></g>
                <g id="nodes-layer"></g>
                <g id="devices-layer"></g>
              </svg>

              <button
                class="map-controls-toggle is-hidden"
                id="map-controls-toggle"
                type="button"
                aria-label="Show map controls"
                aria-controls="map-controls"
                aria-expanded="false"
              >
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="currentColor"
                    d="M10.5 3a7.5 7.5 0 1 1 4.52 13.5l3.74 3.74a1 1 0 0 1-1.42 1.42l-3.74-3.74A7.5 7.5 0 0 1 10.5 3zm0 2a5.5 5.5 0 1 0 0 11a5.5 5.5 0 0 0 0-11z"
                  />
                </svg>
              </button>

              <div class="map-controls" id="map-controls" aria-label="Map controls">
                <div class="map-controls__top">
                  <div class="map-controls__camera" aria-label="Launch view values">
                    <div class="map-controls__camera-line">
                      <span class="map-controls__label">Scale</span>
                      <span class="map-controls__value" id="map-launch-scale">1.000</span>
                      <span class="map-controls__value" id="map-launch-percent" aria-hidden="true">
                        (100%)
                      </span>
                    </div>
                    <div class="map-controls__camera-line">
                      <span class="map-controls__label">X</span>
                      <span class="map-controls__value" id="map-launch-x">0</span>
                      <span class="map-controls__label">Y</span>
                      <span class="map-controls__value" id="map-launch-y">0</span>
                    </div>
                  </div>
                  <button
                    class="map-controls__close"
                    type="button"
                    id="map-controls-close"
                    aria-label="Hide map controls"
                  >
                    ✕
                  </button>
                </div>
                <div class="map-controls__row">
                  <div class="map-controls__stack" aria-label="Pan up/down">
                    <button
                      class="map-controls__btn"
                      type="button"
                      id="map-pan-up"
                      aria-label="Pan up"
                    >
                      ↑
                    </button>
                    <button
                      class="map-controls__btn"
                      type="button"
                      id="map-pan-down"
                      aria-label="Pan down"
                    >
                      ↓
                    </button>
                  </div>

                  <div class="map-controls__zoom">
                    <div class="map-controls__zoom-head">
                      <label class="map-controls__label" for="map-zoom">Zoom</label>
                      <div class="map-controls__value" id="map-zoom-value" aria-hidden="true">
                        100%
                      </div>
                    </div>
                    <input
                      id="map-zoom"
                      class="map-controls__slider"
                      type="range"
                      min="50"
                      max="300"
                      value="100"
                      step="1"
                      aria-label="Zoom"
                    />
                  </div>

                  <div class="map-controls__stack" aria-label="Pan right/left">
                    <button
                      class="map-controls__btn"
                      type="button"
                      id="map-pan-right"
                      aria-label="Pan right"
                    >
                      →
                    </button>
                    <button
                      class="map-controls__btn"
                      type="button"
                      id="map-pan-left"
                      aria-label="Pan left"
                    >
                      ←
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <section
              id="media-window"
              class="tile media-window is-hidden"
              aria-label="Media player window"
            >
              <div
                class="media-window__header"
                id="media-window-handle"
                aria-label="Drag media window"
              >
                <div class="media-window__title">
                  <span class="media-window__pill">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path
                        fill="rgba(234,231,223,0.85)"
                        d="M12 3c5 0 9 4 9 9s-4 9-9 9-9-4-9-9 4-9 9-9zm-1 5v8l7-4-7-4z"
                      />
                    </svg>
                    Media
                  </span>
                  <span class="media-window__hint">Drag</span>
                </div>
              </div>

              <div class="media" aria-label="Now playing">
                <div class="track" id="media-track">Dawn</div>
                <div class="artist" id="media-artist">Kelly Moran</div>
              </div>

              <div class="controls" aria-label="Media controls">
                <div class="buttons" role="group" aria-label="Playback">
                  <div class="btn" aria-hidden="true">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path
                        fill="rgba(234,231,223,0.85)"
                        d="M11 18V6l-8.5 6L11 18zm1-12v12h2V6h-2z"
                      />
                    </svg>
                  </div>
                  <div class="btn" aria-hidden="true">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path fill="rgba(234,231,223,0.85)" d="M8 5v14l11-7z" />
                    </svg>
                  </div>
                  <div class="btn" aria-hidden="true">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path fill="rgba(234,231,223,0.85)" d="M13 6v12l8.5-6L13 6zM4 18h2V6H4v12z" />
                    </svg>
                  </div>
                </div>
                <div class="scrub" aria-hidden="true"><span></span></div>
              </div>
            </section>
          </main>
        </div>
      </div>
    </div>

    <script>
      (function () {
        const SVG_NS = 'http://www.w3.org/2000/svg';
        let suppressRoomClick = false;

        function stripComments(line) {
          const idx = line.indexOf('#');
          if (idx === -1) return line;
          return line.slice(0, idx);
        }

        function unquote(value) {
          const v = value.trim();
          if ((v.startsWith("'") && v.endsWith("'")) || (v.startsWith('"') && v.endsWith('"'))) {
            return v.slice(1, -1);
          }
          return v;
        }

        function coerceScalar(value) {
          const raw = unquote(value);
          if (raw === '') return '';
          if (raw === 'true') return true;
          if (raw === 'false') return false;
          const n = Number(raw);
          if (!Number.isNaN(n) && String(n) === raw.replace(/\.0+$/, '').replace(/\.$/, ''))
            return n;
          if (!Number.isNaN(n) && /^-?\d+(\.\d+)?$/.test(raw)) return n;
          return raw;
        }

        function parseInlineArray(text) {
          const t = text.trim();
          if (!t.startsWith('[') || !t.endsWith(']')) return null;
          const jsonish = t.replace(/'([^']*)'/g, '"$1"');
          try {
            return JSON.parse(jsonish);
          } catch {
            return null;
          }
        }

        function parseYamlLite(yamlText) {
          const lines = yamlText
            .split(/\r?\n/)
            .map((l) => stripComments(l))
            .map((l) => l.replace(/\t/g, '    '));

          function nextNonEmpty(startIdx) {
            let i = startIdx;
            while (i < lines.length) {
              if (lines[i].trim() !== '') return i;
              i++;
            }
            return i;
          }

          function indentOf(line) {
            const m = line.match(/^\s*/);
            return m ? m[0].length : 0;
          }

          function parseBlock(startIdx, baseIndent) {
            let idx = nextNonEmpty(startIdx);
            if (idx >= lines.length) return [{}, idx];

            const isSeq = lines[idx].trimStart().startsWith('- ');
            if (isSeq) {
              const arr = [];
              while (idx < lines.length) {
                idx = nextNonEmpty(idx);
                if (idx >= lines.length) break;
                const line = lines[idx];
                const ind = indentOf(line);
                if (ind < baseIndent) break;
                if (ind !== baseIndent || !line.trimStart().startsWith('- ')) break;

                const afterDash = line.trimStart().slice(2);
                if (afterDash.includes(':')) {
                  const colon = afterDash.indexOf(':');
                  const k = afterDash.slice(0, colon).trim();
                  const rest = afterDash.slice(colon + 1).trim();
                  const obj = {};
                  if (rest === '') {
                    const [nested, nextIdx] = parseBlock(idx + 1, baseIndent + 2);
                    obj[k] = nested;
                    arr.push(obj);
                    idx = nextIdx;
                    continue;
                  }
                  const inlineArr = parseInlineArray(rest);
                  obj[k] = inlineArr !== null ? inlineArr : coerceScalar(rest);
                  idx++;
                  const nextIdx = nextNonEmpty(idx);
                  if (nextIdx < lines.length && indentOf(lines[nextIdx]) > baseIndent) {
                    const [more, doneIdx] = parseBlock(idx, baseIndent + 2);
                    if (more && typeof more === 'object' && !Array.isArray(more)) {
                      Object.assign(obj, more);
                    }
                    idx = doneIdx;
                  }
                  arr.push(obj);
                  continue;
                }

                const inlineArr = parseInlineArray(afterDash);
                if (inlineArr !== null) {
                  arr.push(inlineArr);
                  idx++;
                  continue;
                }
                if (afterDash.trim() === '') {
                  const [nested, nextIdx] = parseBlock(idx + 1, baseIndent + 2);
                  arr.push(nested);
                  idx = nextIdx;
                  continue;
                }
                arr.push(coerceScalar(afterDash));
                idx++;
              }
              return [arr, idx];
            }

            const obj = {};
            while (idx < lines.length) {
              idx = nextNonEmpty(idx);
              if (idx >= lines.length) break;
              const line = lines[idx];
              const ind = indentOf(line);
              if (ind < baseIndent) break;
              if (ind !== baseIndent) break;
              const trimmed = line.trim();
              const colon = trimmed.indexOf(':');
              if (colon === -1) {
                idx++;
                continue;
              }
              const key = trimmed.slice(0, colon).trim();
              const rest = trimmed.slice(colon + 1).trim();
              if (rest === '') {
                const [nested, nextIdx] = parseBlock(idx + 1, baseIndent + 2);
                obj[key] = nested;
                idx = nextIdx;
                continue;
              }
              const inlineArr = parseInlineArray(rest);
              obj[key] = inlineArr !== null ? inlineArr : coerceScalar(rest);
              idx++;
            }
            return [obj, idx];
          }

          const [doc] = parseBlock(0, 0);
          return doc;
        }

        function svgEl(tag, attrs) {
          const el = document.createElementNS(SVG_NS, tag);
          if (attrs) {
            for (const [k, v] of Object.entries(attrs)) {
              el.setAttribute(k, String(v));
            }
          }
          return el;
        }

        function centroid(points) {
          let sx = 0;
          let sy = 0;
          for (const [x, y] of points) {
            sx += x;
            sy += y;
          }
          return [sx / points.length, sy / points.length];
        }

        function computeBounds(rooms) {
          let minX = Infinity;
          let minY = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          for (const room of rooms) {
            for (const [x, y] of room.points) {
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            }
          }
          if (!Number.isFinite(minX)) return { minX: 0, minY: 0, maxX: 10, maxY: 10 };
          return { minX, minY, maxX, maxY };
        }

        function renderFloorplan(doc, devicesDoc) {
          const svg = document.getElementById('floorplan-svg');
          const layer = document.getElementById('rooms-layer');
          const nodesLayer = document.getElementById('nodes-layer');
          const devicesLayer = document.getElementById('devices-layer');
          if (!svg || !layer) return;

          const floors = Array.isArray(doc?.floors) ? doc.floors : [];

          // Floor selection
          // Priority:
          // 1) Root-level `default_floor_id` string
          // 2) Legacy fallback: floor id == 'ground'
          // 3) First floor
          const preferredFloorId =
            typeof doc?.default_floor_id === 'string' ? String(doc.default_floor_id).trim() : '';

          const floorById = preferredFloorId
            ? floors.find((f) => String(f?.id || '').trim() === preferredFloorId)
            : null;

          const floor = floorById || floors.find((f) => f?.id === 'ground') || floors[0];
          const floorInitialView = {
            scale: Number(floor?.initial_scale),
            x: Number(floor?.initial_x),
            y: Number(floor?.initial_y),
          };
          const rooms = Array.isArray(floor?.rooms) ? floor.rooms : [];
          const nodes = Array.isArray(floor?.nodes)
            ? floor.nodes
            : Array.isArray(doc?.nodes)
              ? doc.nodes
              : [];
          const floorBounds = Array.isArray(floor?.bounds) ? floor.bounds : null;
          const roomsNormalized = rooms
            .filter((r) => r && Array.isArray(r.points))
            .map((r) => ({
              id: String(r.id || r.name || '').trim(),
              name: String(r.name || r.id || '').trim(),
              points: r.points.map((p) => [Number(p[0]), Number(p[1])]),
            }))
            .filter((r) => r.id && r.points.length >= 3);

          const nodesNormalized = nodes
            .filter((n) => n)
            .map((n) => {
              const point = Array.isArray(n.point)
                ? n.point
                : Array.isArray(n.points)
                  ? n.points
                  : null;
              const x = point ? Number(point[0]) : Number(n.x);
              const y = point ? Number(point[1]) : Number(n.y);
              return {
                id: String(n.id || n.name || '').trim(),
                name: String(n.name || n.id || '').trim(),
                x,
                y,
              };
            })
            .filter((n) => n.id && n.name && Number.isFinite(n.x) && Number.isFinite(n.y));

          const boundsFromFloor =
            floorBounds &&
            floorBounds.length >= 2 &&
            Array.isArray(floorBounds[0]) &&
            Array.isArray(floorBounds[1])
              ? {
                  minX: Number(floorBounds[0][0]),
                  minY: Number(floorBounds[0][1]),
                  maxX: Number(floorBounds[1][0]),
                  maxY: Number(floorBounds[1][1]),
                }
              : null;

          const { minX, minY, maxX, maxY } = boundsFromFloor || computeBounds(roomsNormalized);
          const pad = 1.25;
          const vbX = minX - pad;
          const vbY = minY - pad;
          const vbW = maxX - minX + pad * 2;
          const vbH = maxY - minY + pad * 2;
          svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);

          // YAML coordinates treat positive Y as north/up.
          // SVG increases Y downward, so we flip within the computed viewBox.
          const flipY = (y) => 2 * vbY + vbH - y;
          const roomsForRender = roomsNormalized.map((room) => ({
            ...room,
            points: room.points.map(([x, y]) => [x, flipY(y)]),
          }));

          const nodesForRender = nodesNormalized.map((node) => ({
            ...node,
            y: flipY(node.y),
          }));

          const originGps = doc?.gps && typeof doc.gps === 'object' ? doc.gps : null;
          const devices = Array.isArray(devicesDoc?.devices) ? devicesDoc.devices : [];
          const devicesNormalized = devices
            .filter((d) => d)
            .map((d) => {
              const fallbackGps = [
                d.latitude ?? d.lat ?? d.lattitude,
                d.longitude ?? d.lon ?? d.lng ?? d.longtitude,
                d.elevation ?? d.altitude ?? d.alt,
              ];
              const deviceGps = Array.isArray(d.gps) ? d.gps : fallbackGps;
              const local = gpsToLocalMeters(deviceGps, originGps);
              if (!local) return null;
              return {
                id: String(d.id || d.label || '').trim(),
                label: String(d.label || d.id || '').trim(),
                color: String(d.color || '').trim(),
                x: local.x,
                y: local.y,
                z: local.z,
              };
            })
            .filter((d) => d && d.id && d.label && Number.isFinite(d.x) && Number.isFinite(d.y));

          const devicesForRender = devicesNormalized.map((d) => ({
            ...d,
            y: flipY(d.y),
          }));

          while (layer.firstChild) layer.removeChild(layer.firstChild);
          if (nodesLayer instanceof SVGGElement) {
            while (nodesLayer.firstChild) nodesLayer.removeChild(nodesLayer.firstChild);
          }
          if (devicesLayer instanceof SVGGElement) {
            while (devicesLayer.firstChild) devicesLayer.removeChild(devicesLayer.firstChild);
          }

          let activeId = null;

          function setActive(id) {
            activeId = id;
            for (const g of layer.querySelectorAll('.room')) {
              g.classList.toggle('is-active', g.getAttribute('data-room-id') === id);
            }
          }

          for (const room of roomsForRender) {
            const g = svgEl('g', {
              class: 'room',
              'data-room-id': room.id,
              tabindex: '0',
              role: 'button',
              'aria-label': room.name,
            });

            const pts = room.points.map(([x, y]) => `${x},${y}`).join(' ');
            const poly = svgEl('polygon', { points: pts, class: 'room-shape' });
            g.appendChild(poly);

            const [cx, cy] = centroid(room.points);
            const label = svgEl('text', {
              x: cx,
              y: cy,
              'text-anchor': 'middle',
              'dominant-baseline': 'middle',
              class: 'room-label',
            });
            label.textContent = room.name;
            g.appendChild(label);

            g.addEventListener('click', (e) => {
              e.preventDefault();
              if (suppressRoomClick) {
                suppressRoomClick = false;
                return;
              }
              setActive(room.id);
              // Some browsers don't reliably move focus to SVG elements on click.
              // Keep focus on the selected room for keyboard continuity.
              g.focus({ preventScroll: true });
            });
            g.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                setActive(room.id);
              }
            });

            layer.appendChild(g);
          }

          if (nodesLayer instanceof SVGGElement) {
            for (const node of nodesForRender) {
              const dot = svgEl('circle', {
                class: 'node-dot',
                cx: node.x,
                cy: node.y,
                r: 0.12,
                'data-node-id': node.id,
              });
              nodesLayer.appendChild(dot);

              const label = svgEl('text', {
                class: 'node-label',
                x: node.x,
                y: node.y,
                'text-anchor': 'middle',
                'dominant-baseline': 'middle',
                dy: '-0.9em',
                'data-node-id': node.id,
              });
              label.textContent = node.name;
              nodesLayer.appendChild(label);
            }
          }

          if (devicesLayer instanceof SVGGElement) {
            for (const device of devicesForRender) {
              const g = svgEl('g', {
                class: 'device-marker',
                transform: `translate(${device.x} ${device.y})`,
                'data-device-id': device.id,
                style: device.color ? `color: ${device.color};` : '',
                'aria-label': device.label,
              });

              const use = svgEl('use', {
                class: 'device-pin',
                href: '#devicePin',
                'xlink:href': '#devicePin',
                x: 0,
                y: 0,
                width: 1,
                height: 1,
              });
              g.appendChild(use);

              const label = svgEl('text', {
                class: 'device-label',
                x: 0,
                y: 0,
                'text-anchor': 'middle',
                'dominant-baseline': 'middle',
                'data-device-id': device.id,
              });
              label.textContent = device.label;
              g.appendChild(label);

              devicesLayer.appendChild(g);
            }
          }

          if (roomsForRender.length) setActive(roomsForRender[0].id);

          return {
            floorId: String(floor?.id || ''),
            roomsCount: roomsForRender.length,
            devicesCount: devicesForRender.length,
            viewBox: `${vbX} ${vbY} ${vbW} ${vbH}`,
            baseViewBox: { x: vbX, y: vbY, w: vbW, h: vbH },
            initialView: {
              scale: Number.isFinite(floorInitialView.scale) ? floorInitialView.scale : null,
              x: Number.isFinite(floorInitialView.x) ? floorInitialView.x : null,
              y: Number.isFinite(floorInitialView.y) ? floorInitialView.y : null,
            },
          };
        }

        function enablePanZoom(baseViewBox, initialView) {
          const svg = document.getElementById('floorplan-svg');
          if (!(svg instanceof SVGSVGElement) || !baseViewBox) return;

          const controls = document.getElementById('map-controls');
          const controlsClose = document.getElementById('map-controls-close');
          const controlsToggle = document.getElementById('map-controls-toggle');

          const setControlsVisible = (visible) => {
            if (controls instanceof HTMLElement) {
              controls.classList.toggle('is-hidden', !visible);
            }
            if (controlsToggle instanceof HTMLElement) {
              controlsToggle.classList.toggle('is-hidden', visible);
              controlsToggle.setAttribute('aria-expanded', visible ? 'true' : 'false');
            }
          };

          if (controlsClose instanceof HTMLButtonElement) {
            controlsClose.addEventListener('click', () => setControlsVisible(false));
          }
          if (controlsToggle instanceof HTMLButtonElement) {
            controlsToggle.addEventListener('click', () => setControlsVisible(true));
          }

          // Default: controls visible, toggle hidden.
          setControlsVisible(false);

          const zoomSlider = document.getElementById('map-zoom');
          const zoomValue = document.getElementById('map-zoom-value');
          const launchScaleValue = document.getElementById('map-launch-scale');
          const launchPercentValue = document.getElementById('map-launch-percent');
          const launchXValue = document.getElementById('map-launch-x');
          const launchYValue = document.getElementById('map-launch-y');
          const panUp = document.getElementById('map-pan-up');
          const panDown = document.getElementById('map-pan-down');
          const panLeft = document.getElementById('map-pan-left');
          const panRight = document.getElementById('map-pan-right');

          const minScale = 0.5;
          const maxScale = 3.0;

          let current = { ...baseViewBox };
          let scale = 1.0;

          const pointers = new Map();
          let mouseDragging = false;
          let dragStart = null;
          let dragMoved = false;
          let gestureStart = null;

          // Increase/decrease device marker size (in screen pixels) without affecting map scale.
          const DEVICE_PIN_SCALE = 2.1;

          const updateRoomLabelSizes = (desiredPx = 14) => {
            const rect = svg.getBoundingClientRect();
            if (!rect.width) return;
            const vb = readViewBox();
            const unitsPerPx = vb.w / rect.width;
            const roomFontSizeInUserUnits = desiredPx * unitsPerPx;
            const nodeFontSizeInUserUnits = 11 * unitsPerPx;
            const nodeRadiusInUserUnits = 4 * unitsPerPx;
            const deviceLabelFontSizeInUserUnits = 11 * unitsPerPx;
            const devicePinHeightInUserUnits = 34 * DEVICE_PIN_SCALE * unitsPerPx;
            const devicePinWidthInUserUnits = 26 * DEVICE_PIN_SCALE * unitsPerPx;
            const deviceLabelGapInUserUnits = 6 * DEVICE_PIN_SCALE * unitsPerPx;

            const roomLabels = svg.querySelectorAll('.room-label');
            for (const label of roomLabels) {
              if (label instanceof SVGTextElement) {
                label.setAttribute('font-size', String(roomFontSizeInUserUnits));
              }
            }

            const nodeLabels = svg.querySelectorAll('.node-label');
            for (const label of nodeLabels) {
              if (label instanceof SVGTextElement) {
                label.setAttribute('font-size', String(nodeFontSizeInUserUnits));
              }
            }

            const nodeDots = svg.querySelectorAll('.node-dot');
            for (const dot of nodeDots) {
              if (dot instanceof SVGCircleElement) {
                dot.setAttribute('r', String(nodeRadiusInUserUnits));
              }
            }

            const deviceMarkers = svg.querySelectorAll('.device-marker');
            for (const g of deviceMarkers) {
              if (!(g instanceof SVGGElement)) continue;

              const use = g.querySelector('.device-pin');
              if (use instanceof SVGUseElement) {
                use.setAttribute('width', String(devicePinWidthInUserUnits));
                use.setAttribute('height', String(devicePinHeightInUserUnits));
                use.setAttribute('x', String(-devicePinWidthInUserUnits / 2));
                use.setAttribute('y', String(-devicePinHeightInUserUnits));
              }

              const label = g.querySelector('.device-label');
              if (label instanceof SVGTextElement) {
                label.setAttribute('font-size', String(deviceLabelFontSizeInUserUnits));
                label.setAttribute('x', '0');
                label.setAttribute(
                  'y',
                  String(-devicePinHeightInUserUnits - deviceLabelGapInUserUnits)
                );
              }
            }
          };

          const clampScale = (s) => Math.min(maxScale, Math.max(minScale, s));

          const scaleFromViewBox = (vb) => {
            if (!vb?.w) return 1.0;
            return clampScale(baseViewBox.w / vb.w);
          };

          const formatNumber = (value, decimals) => {
            if (!Number.isFinite(value)) return '';
            return value.toFixed(decimals);
          };

          const updateLaunchReadout = (vb) => {
            const computedScale = scaleFromViewBox(vb);
            const percent = Math.round(computedScale * 100);

            if (launchScaleValue instanceof HTMLElement) {
              launchScaleValue.textContent = formatNumber(computedScale, 3);
            }
            if (launchPercentValue instanceof HTMLElement) {
              launchPercentValue.textContent = `(${percent}%)`;
            }
            if (launchXValue instanceof HTMLElement) {
              launchXValue.textContent = formatNumber(vb.x, 2);
            }
            if (launchYValue instanceof HTMLElement) {
              launchYValue.textContent = formatNumber(vb.y, 2);
            }
          };

          const applyViewBox = (vb) => {
            current = vb;
            svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
            updateRoomLabelSizes(14);
            updateLaunchReadout(vb);
          };

          const readViewBox = () => {
            const parts = String(svg.getAttribute('viewBox') || '')
              .trim()
              .split(/\s+/)
              .map(Number);
            if (parts.length === 4 && parts.every(Number.isFinite)) {
              return { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
            }
            return { ...current };
          };

          const clientToSvg = (clientX, clientY) => {
            const ctm = svg.getScreenCTM();
            if (!ctm) return { x: 0, y: 0 };
            const inv = ctm.inverse();

            if (typeof DOMPoint !== 'undefined') {
              const pt = new DOMPoint(clientX, clientY);
              const out = pt.matrixTransform(inv);
              return { x: out.x, y: out.y };
            }

            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            const out = pt.matrixTransform(inv);
            return { x: out.x, y: out.y };
          };

          const syncControls = () => {
            const vb = readViewBox();
            const computedScale = scaleFromViewBox(vb);
            scale = computedScale;
            const percent = Math.round(computedScale * 100);
            if (zoomSlider instanceof HTMLInputElement) zoomSlider.value = String(percent);
            if (zoomValue instanceof HTMLElement) zoomValue.textContent = `${percent}%`;
          };

          const applyInitialView = () => {
            const yamlScale = Number(initialView?.scale);
            const initialScale = clampScale(Number.isFinite(yamlScale) ? yamlScale : 1.0);
            scale = initialScale;

            const initialW = baseViewBox.w / initialScale;
            const initialH = baseViewBox.h / initialScale;

            const centeredX = baseViewBox.x + (baseViewBox.w - initialW) / 2;
            const centeredY = baseViewBox.y + (baseViewBox.h - initialH) / 2;

            const yamlX = Number(initialView?.x);
            const yamlY = Number(initialView?.y);
            const x = Number.isFinite(yamlX) ? yamlX : centeredX;
            const y = Number.isFinite(yamlY) ? yamlY : centeredY;

            applyViewBox({ x, y, w: initialW, h: initialH });
            syncControls();
          };

          const viewBoxForScaleAround = (startVb, nextScale, focalSvg) => {
            const newW = baseViewBox.w / nextScale;
            const newH = baseViewBox.h / nextScale;
            const fx = focalSvg.x;
            const fy = focalSvg.y;
            const newX = fx - ((fx - startVb.x) * newW) / startVb.w;
            const newY = fy - ((fy - startVb.y) * newH) / startVb.h;
            return { x: newX, y: newY, w: newW, h: newH };
          };

          const setScaleAround = (nextScale, focalSvg) => {
            const vb = readViewBox();
            const clamped = clampScale(nextScale);
            scale = clamped;
            applyViewBox(viewBoxForScaleAround(vb, clamped, focalSvg));
            syncControls();
          };

          const panByPixels = (dxPx, dyPx) => {
            const rect = svg.getBoundingClientRect();
            if (!rect.width || !rect.height) return;
            const vb = readViewBox();
            const dx = (dxPx * vb.w) / rect.width;
            const dy = (dyPx * vb.h) / rect.height;
            applyViewBox({ ...vb, x: vb.x - dx, y: vb.y - dy });
          };

          applyInitialView();

          window.addEventListener('resize', () => {
            updateRoomLabelSizes(14);
          });

          // Mouse wheel zoom (desktop/laptop)
          svg.addEventListener(
            'wheel',
            (e) => {
              e.preventDefault();
              const focal = clientToSvg(e.clientX, e.clientY);
              const zoomFactor = Math.pow(1.0016, -e.deltaY);
              const nextScale = clampScale(scale * zoomFactor);
              setScaleAround(nextScale, focal);
            },
            { passive: false }
          );

          // Pointer: click-drag pan (mouse). Touch: pinch zoom + two-finger pan.
          svg.addEventListener('pointerdown', (e) => {
            pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType });

            if (e.pointerType === 'mouse' && e.button === 0) {
              // Do not immediately capture the pointer.
              // Capturing on pointerdown can cause the subsequent click to be retargeted
              // to the SVG (instead of the room), preventing room selection.
              mouseDragging = false;
              dragMoved = false;
              dragStart = { x: e.clientX, y: e.clientY };
            }

            if (e.pointerType !== 'mouse' && pointers.size === 2) {
              const pts = Array.from(pointers.values());
              const a = pts[0];
              const b = pts[1];
              const startMid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
              const startDist = Math.hypot(a.x - b.x, a.y - b.y);
              gestureStart = {
                startViewBox: readViewBox(),
                startScale: scale,
                startMid,
                startDist,
                startMidSvg: clientToSvg(startMid.x, startMid.y),
              };
              svg.classList.add('is-panning');
              e.preventDefault();
            }
          });

          svg.addEventListener('pointermove', (e) => {
            if (!pointers.has(e.pointerId)) return;
            const prev = pointers.get(e.pointerId);
            pointers.set(e.pointerId, { ...prev, x: e.clientX, y: e.clientY });

            if (e.pointerType === 'mouse') {
              const dx = e.clientX - prev.x;
              const dy = e.clientY - prev.y;

              if (dragStart) {
                const moved = Math.hypot(e.clientX - dragStart.x, e.clientY - dragStart.y);
                // Start panning only after a small movement threshold.
                if (!mouseDragging && moved > 4) {
                  mouseDragging = true;
                  dragMoved = true;
                  svg.classList.add('is-panning');
                  try {
                    svg.setPointerCapture(e.pointerId);
                  } catch {
                    // ignore
                  }
                }
              }

              if (mouseDragging) {
                panByPixels(dx, dy);
                e.preventDefault();
                return;
              }
            }

            if (e.pointerType !== 'mouse' && pointers.size === 2 && gestureStart) {
              const pts = Array.from(pointers.values());
              const a = pts[0];
              const b = pts[1];
              const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
              const dist = Math.hypot(a.x - b.x, a.y - b.y);

              const zoomFactor = gestureStart.startDist > 0 ? dist / gestureStart.startDist : 1;
              const nextScale = clampScale(gestureStart.startScale * zoomFactor);
              const vb1 = viewBoxForScaleAround(
                gestureStart.startViewBox,
                nextScale,
                gestureStart.startMidSvg
              );

              // Apply two-finger pan based on midpoint movement
              const rect = svg.getBoundingClientRect();
              if (rect.width && rect.height) {
                const dxPx = mid.x - gestureStart.startMid.x;
                const dyPx = mid.y - gestureStart.startMid.y;
                vb1.x -= (dxPx * vb1.w) / rect.width;
                vb1.y -= (dyPx * vb1.h) / rect.height;
              }

              scale = nextScale;
              applyViewBox(vb1);
              syncControls();
              e.preventDefault();
            }
          });

          const endPointer = (e) => {
            const wasMouse = e.pointerType === 'mouse';
            pointers.delete(e.pointerId);

            if (wasMouse) {
              mouseDragging = false;
              svg.classList.remove('is-panning');
              if (dragMoved) {
                suppressRoomClick = true;
                setTimeout(() => {
                  suppressRoomClick = false;
                }, 0);
              }
              dragStart = null;
              dragMoved = false;
              try {
                svg.releasePointerCapture(e.pointerId);
              } catch {
                // ignore
              }
            } else if (pointers.size < 2) {
              gestureStart = null;
              svg.classList.remove('is-panning');
              // Two-finger gestures should not trigger room clicks.
              suppressRoomClick = true;
              setTimeout(() => {
                suppressRoomClick = false;
              }, 0);
            }
          };

          svg.addEventListener('pointerup', endPointer);
          svg.addEventListener('pointercancel', endPointer);

          // Slider zoom (starter on-screen control)
          if (zoomSlider instanceof HTMLInputElement) {
            zoomSlider.addEventListener('input', () => {
              const nextScale = clampScale(Number(zoomSlider.value) / 100);
              const vb = readViewBox();
              const focal = { x: vb.x + vb.w / 2, y: vb.y + vb.h / 2 };
              setScaleAround(nextScale, focal);
            });
          }

          // Arrow pad + keyboard arrows
          const panStep = (dxSign, dySign) => {
            const vb = readViewBox();
            applyViewBox({
              ...vb,
              x: vb.x + vb.w * 0.1 * dxSign,
              y: vb.y + vb.h * 0.1 * dySign,
            });
          };

          const bindPanButton = (el, dx, dy) => {
            if (!(el instanceof HTMLButtonElement)) return;
            el.addEventListener('click', () => panStep(dx, dy));
          };

          bindPanButton(panUp, 0, -1);
          bindPanButton(panDown, 0, 1);
          bindPanButton(panLeft, -1, 0);
          bindPanButton(panRight, 1, 0);

          window.addEventListener('keydown', (e) => {
            const active = document.activeElement;
            const typing =
              active instanceof HTMLInputElement ||
              active instanceof HTMLTextAreaElement ||
              (active instanceof HTMLElement && active.isContentEditable);
            if (typing) return;

            if (e.key === 'ArrowUp') {
              e.preventDefault();
              panStep(0, -1);
            } else if (e.key === 'ArrowDown') {
              e.preventDefault();
              panStep(0, 1);
            } else if (e.key === 'ArrowLeft') {
              e.preventDefault();
              panStep(-1, 0);
            } else if (e.key === 'ArrowRight') {
              e.preventDefault();
              panStep(1, 0);
            }
          });
        }

        function normalizeYamlText(text) {
          const raw = String(text || '').replace(/^\uFEFF/, '');
          const lines = raw.split(/\r?\n/);
          let minIndent = Infinity;
          for (const line of lines) {
            if (line.trim() === '') continue;
            const leading = (line.match(/^\s*/) || [''])[0].length;
            minIndent = Math.min(minIndent, leading);
          }
          if (!Number.isFinite(minIndent) || minIndent <= 0) return raw;
          return lines.map((l) => (l.length >= minIndent ? l.slice(minIndent) : l)).join('\n');
        }

        function isProbablyHtml(text) {
          const trimmed = String(text || '').trimStart().toLowerCase();
          if (!trimmed) return false;
          if (trimmed.startsWith('<!doctype html')) return true;
          if (trimmed.startsWith('<html')) return true;
          return trimmed.startsWith('<') && trimmed.includes('<head') && trimmed.includes('<body');
        }

        async function loadYamlText(path, fallbackId) {
          try {
            const res = await fetch(path, { cache: 'no-store' });
            if (res.ok) {
              const text = await res.text();
              if (isProbablyHtml(text)) {
                return { text: '', source: 'none' };
              }
              return { text, source: 'fetch' };
            }
          } catch {
            // ignore
          }
          if (fallbackId) {
            const fallback = document.getElementById(fallbackId);
            if (fallback) {
              return { text: fallback.textContent || '', source: 'fallback' };
            }
          }
          return { text: '', source: 'none' };
        }

        function toRadians(deg) {
          return (deg * Math.PI) / 180;
        }

        function gpsToLocalMeters(deviceGps, originGps) {
          if (!Array.isArray(deviceGps) || deviceGps.length < 2) return null;
          if (!originGps || typeof originGps !== 'object') return null;

          const lat = Number(deviceGps[0]);
          const lon = Number(deviceGps[1]);
          const elev = deviceGps.length >= 3 ? Number(deviceGps[2]) : Number.NaN;

          const lat0 = Number(originGps.latitude);
          const lon0 = Number(originGps.longitude);
          const elev0 = Number(originGps.elevation || 0);

          if (![lat, lon, lat0, lon0].every(Number.isFinite)) return null;

          // Local tangent-plane approximation (meters): x=east, y=north
          const R = 6378137;
          const dLat = toRadians(lat - lat0);
          const dLon = toRadians(lon - lon0);
          const x = dLon * Math.cos(toRadians(lat0)) * R;
          const y = dLat * R;
          const z = Number.isFinite(elev) ? elev - elev0 : 0;

          return { x, y, z };
        }

        function enableDragging() {
          const stage = document.querySelector('.stage');
          const win = document.getElementById('media-window');
          const handle = document.getElementById('media-window-handle');
          if (
            !(stage instanceof HTMLElement) ||
            !(win instanceof HTMLElement) ||
            !(handle instanceof HTMLElement)
          ) {
            return;
          }

          let startX = 0;
          let startY = 0;
          let startLeft = 0;
          let startTop = 0;
          let dragging = false;

          function clamp(v, min, max) {
            return Math.min(Math.max(v, min), max);
          }

          handle.addEventListener('pointerdown', (e) => {
            dragging = true;
            handle.setPointerCapture(e.pointerId);
            const rect = win.getBoundingClientRect();
            const stageRect = stage.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            startLeft = rect.left - stageRect.left;
            startTop = rect.top - stageRect.top;
          });

          handle.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const stageRect = stage.getBoundingClientRect();
            const w = win.offsetWidth;
            const h = win.offsetHeight;
            const margin = 10;
            const maxLeft = stageRect.width - w - margin;
            const maxTop = stageRect.height - h - margin;
            const nextLeft = clamp(startLeft + dx, margin, Math.max(margin, maxLeft));
            const nextTop = clamp(startTop + dy, margin, Math.max(margin, maxTop));
            win.style.left = `${nextLeft}px`;
            win.style.top = `${nextTop}px`;
          });

          handle.addEventListener('pointerup', (e) => {
            dragging = false;
            try {
              handle.releasePointerCapture(e.pointerId);
            } catch {
              // ignore
            }
          });
        }

        function enableMediaToggle() {
          const toggleButton = document.getElementById('media-toggle');
          const win = document.getElementById('media-window');

          if (!(toggleButton instanceof HTMLButtonElement) || !(win instanceof HTMLElement)) {
            return;
          }

          const isHidden = () => win.classList.contains('is-hidden');
          const syncAria = () =>
            toggleButton.setAttribute('aria-expanded', isHidden() ? 'false' : 'true');

          syncAria();

          toggleButton.addEventListener('click', () => {
            win.classList.toggle('is-hidden');
            syncAria();
          });
        }

        (async function init() {
          enableDragging();
          enableMediaToggle();
          const statusEl = document.getElementById('floorplan-status');
          const emptyEl = document.getElementById('floorplan-empty');
          const emptyMessageEl = document.getElementById('floorplan-empty-message');
          const retryButton = document.getElementById('floorplan-retry');

          const showEmptyMessage = (msg) => {
            if (statusEl) statusEl.textContent = msg;
            if (emptyMessageEl) emptyMessageEl.textContent = msg;
            if (emptyEl) emptyEl.classList.remove('is-hidden');
            if (retryButton instanceof HTMLButtonElement) retryButton.disabled = false;
          };

          const hideEmptyMessage = () => {
            if (emptyEl) emptyEl.classList.add('is-hidden');
          };

          const loadAndRender = async () => {
            if (retryButton instanceof HTMLButtonElement) retryButton.disabled = true;

            try {
              const [{ text, source }, { text: devicesText, source: devicesSource }] =
                await Promise.all([
                  loadYamlText('./floorplan.yaml', ''),
                  loadYamlText('./devices.yaml', 'devices-yaml'),
                ]);

              if (!String(text || '').trim()) {
                const msg =
                  'No floorplan.yaml has been provided.\n\n' +
                  "If you have not created your own yet, please copy the provided floorplan-example.yaml and name it floorplan.yaml so you have a working example.";
                showEmptyMessage(msg);
                console.error(msg);
                return;
              }

              const normalized = normalizeYamlText(text);
              if (isProbablyHtml(normalized)) {
                const msg =
                  'No floorplan.yaml has been provided.\n\n' +
                  "If you have not created your own yet, please copy the provided floorplan-example.yaml and name it floorplan.yaml so you have a working example.";
                showEmptyMessage(msg);
                console.error(msg);
                return;
              }
              const doc = parseYamlLite(normalized);

              const normalizedDevices = normalizeYamlText(devicesText);
              const devicesDoc = parseYamlLite(normalizedDevices);
              const floorsCount = Array.isArray(doc?.floors) ? doc.floors.length : 0;

              if (floorsCount === 0) {
                const msg =
                  'No floorplan.yaml has been provided.\n\n' +
                  "If you have not created your own yet, please copy the provided floorplan-example.yaml and name it floorplan.yaml so you have a working example.";
                showEmptyMessage(msg);
                console.error(msg);
                return;
              }

              hideEmptyMessage();

              const result = renderFloorplan(doc, devicesDoc);
              if (result?.baseViewBox) {
                enablePanZoom(result.baseViewBox, result.initialView);
              }
              const roomsCount = result?.roomsCount ?? 0;
              const devicesCount = result?.devicesCount ?? 0;
              const floorId = result?.floorId ?? 'unknown';
              const viewBox = result?.viewBox ?? '(none)';

              const defaultFloorId =
                typeof doc?.default_floor_id === 'string'
                  ? String(doc.default_floor_id).trim()
                  : '';
              const defaultFloorMatch =
                defaultFloorId && floorId ? defaultFloorId === String(floorId).trim() : false;
              const defaultFloorNote = defaultFloorId
                ? defaultFloorMatch
                  ? ' (matched)'
                  : ' (no match)'
                : '';

              const msg =
                `Floorplan: ok\n` +
                `source: ${source}\n` +
                `devices: ${devicesSource}\n` +
                `default_floor_id: ${defaultFloorId || '(none)'}${defaultFloorNote}\n` +
                `floors: ${floorsCount}  floor: ${floorId}\n` +
                `rooms: ${roomsCount}\n` +
                `devices: ${devicesCount}\n` +
                `viewBox: ${viewBox}`;

              if (statusEl) statusEl.textContent = msg;
              console.log(msg);
            } catch (err) {
              const msg = `Floorplan: ERROR\n${String(err)}`;
              showEmptyMessage(msg);
              console.error(err);
            } finally {
              if (retryButton instanceof HTMLButtonElement) retryButton.disabled = false;
            }
          };

          if (retryButton instanceof HTMLButtonElement) {
            retryButton.addEventListener('click', () => {
              void loadAndRender();
            });
          }

          await loadAndRender();
        })();
      })();
    </script>
  </body>
</html>
